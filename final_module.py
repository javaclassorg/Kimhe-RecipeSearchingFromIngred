"""
For searching and showing proper menu based on ingredients of refrigerator,
refer the text recipe files in 'menu' directory(directory and files can generated by running 'menu_gen_(date).py').
The main program is 'final_GUI.exe', and with that program you can choose one or two ingredients.
As a result of search, this program will show the ingredient list and recipes to user.

menu_gen_(date).py를 통해 생성된 가상의 레시피 pool을 바탕으로, 사용자로부터 1~2개의 재료를 선택받아
선택에 매칭되는 레시피만을 찾아내고, 사용자가 보기 좋도록 출력해주는 프로그램이다.
# 본 프로그램을 꼭 레시피가 아니더라도, 특정 디렉터리 내부의 txt형식의 파일들을 탐색하여 원하는 값을 찾아내는 기능을 가지고 있으므로,
# 시판 화장품들 중 알러지 성분을 포함하는 화장품명 검색, 간편식품 중 유해 식품첨가물을 포함하는 식품명 검색 등 코드의 일부 재사용이 가능하다.
# 그 밖에도... 추후, txt파일의 DB화(.json, .xml 형식 활용), txt파일을 위한 크롤링 기술 등이 추가 될 여지가 있다.

$ python final_module.py

Author : hekim
Working Log : 2020-08-17 19:36(ver.1)
         2020-08-18 (ver.2_코드 수정 및 주석 추가) _ 개선예정작업 : 분산된 메인코드 재정렬 및, 너무 긴 코드 함수화, 프로그램 효율성 재고
         2020-08-18 (ver.2.1_사용자가 1~14번 외에도 222번 등을 입력가능한 부분 발견 후 except IndexError: 추가(추후 재 개선 예정))
         2020-08-20 (ver.3_함수로만 기술했던 프로그램을 클래스화 함(GUI와의 연동 편의를 위해서), 코드 대폭 변경)
         2020-08-21 (ver.4_GUI연동 과정에서 show_textview1,2, runprogram1,2 메서드 소스 수정 및 기타부분 대폭 수정...) _ 1차 완성
         2020-08-24 (ver.4.1_ret_nameandingr()함수의 인덱싱이 잘못된 점을 발견하여 수정, 연관된 find_index()도 수정_라인 55,68)
         2020-08-25 (ver.4.2_runprogram1(), ret_m_names() 코드 수정으로 menu디렉토리 미 존재시 강제종료되던 현상 수정) _ final
"""
#!/usr/bin/env python3

import os

class ChoosingMenu():
    def __init__(self, ingt1=None, ingt2=None):
        self.ingt1 = ingt1
        self.ingt2 = ingt2

    # function which return the list of recipe file names.
    def ret_m_names():
        path = ".\\menu"
        if os.path.isdir(".\\menu"):
            file_list = os.listdir(path)
            m_names = []
            for i in file_list:
                m_names.append(i.split(".")[0])
            return m_names
        else:
            #print("can not find 'menu' directory.")
            return None

    # function which return the list consist with dictionary type data such as[{menu name(key):ingredients list(valus)}, ]
    def ret_nameandingr(m_names):
        nameandingr = []
        for i in range(len(m_names)):
            with open(".\\menu\\{}.txt".format(m_names[i]), "r") as f:
                temp_dic = {}
                rdata = f.readline().split(",")
                rdata.append(rdata[len(rdata) - 1].split("\n")[0])
                del rdata[-2]
                temp_dic[m_names[i]] = rdata   # Warning: if using 'temp_dic[m_names[i - 1]] = rdata' return wrong result.
                nameandingr.append(temp_dic)
        return nameandingr
        # example structure of 'nameandingr' : [{'menu_name1': ['apple']}, {'menu_name2': ['apple', 'egg', 'potato']}, . . ]
        # nameandingr의 구조 : 리스트 안에 딕셔너리들을 원소로 가지며, 각 딕셔너리는 키 값으로 메뉴명을 벨류 값으로 해당 재료의 리스트를 가짐
        #                     ex) [{'닗나물': ['파']}, {'먼쓍국': ['어묵', '계란', '감자', '콩나물', '당근', '양파', '우유', '무']}]

    # function which return the specific index numbers of 'nameandingr list(see above)'.
    # returning index numbers are decided by ingredient1, 2 from User of this program(or demo/test value from 'run' code)
    # menu\*.txt 파일들을 가공하여 생성한 리스트(nameandingr)를 참조하여, 사용자 선택 재료 1,2를 반영하는 특정 인덱스 넘버를 반환
    def find_index(self, m_names, nameandingr):
        list_index = []
        for i in range(0, len(m_names) - 1):
            # Warning: if using 'temp_m_ingts = nameandingr[i]["{}".format(m_names[i - 1])]' return wrong result.
            temp_m_ingts = nameandingr[i]["{}".format(m_names[i])]
            # For call the value from dictionary type, using 'dictionaryname[key name]'
            # 벨류 값 호출은 dict명[키값=메뉴명], 여기서 dict명은 nameandingr의 i번째 원소.
                for j in [self.ingt1]:
                    if j in temp_m_ingts:
                        list_index.append(i) #리스트 원소 번호 = i, 찾는 값 = j, 인덱스 번호 = temp_m_ingts.index(j)
            else:
                if self.ingt1 in temp_m_ingts:
                    if self.ingt2 in temp_m_ingts:
                        list_index.append(i) #리스트 원소 번호 = i, 찾는 값 = ingt1, ingt2, 인덱스 번호 = temp_m_ingts.index(ingt1), temp_m_ingts.index(ingt2)
        return list_index

    # function which return the list [[menu names list],["ingredients of {menu_name}: {ingredients list}", "", "". . .]
    # menu names and strings type element decided from list_index of find_index() of above
    def show_textview1(self, nameandingr, list_index):
        founded_mname = []
        for_print_text = []
        for i in list_index:
            temp_convert_s = str(nameandingr[i])
            temp_name = temp_convert_s[2:temp_convert_s.find(":")-1]
            founded_mname.append(temp_name)
            temp_list = "{}의 재료: {}".format(temp_name, ",".join(nameandingr[i][temp_name]))
            for_print_text.append(temp_list)
            #print(temp_name, "의 재료: " ,",".join(nameandingr[i][temp_name]))
        #print("")
        for_print_text.sort(key=len)
        return [founded_mname, for_print_text]

    # This function not using in the GUI(main program) code, only for this module.
    # "[메뉴명] \n 레시피~"의 형태로 메뉴명과 레시피를 출력해주는 함수.
    # function which return the
    #
    def show_textview2(self, result_menus):
        if result_menus == []:
            returnlist = "매칭되는 레시피가 없습니다."
        else:
            returnlist = []
            for i in result_menus:
                with open(".\\menu\\{}.txt".format(i), "r") as f:
                    temp_reci = f.readlines()
                    del temp_reci[0]
                    returnlist.append("{}의 레시피:\n {}".format(i, "".join(temp_reci)))
                    #print("[{}]".format(i))
                    #print("".join(temp_reci))
        return returnlist


# This function accomplish the original purpose of this program by using the methods from ChoosingMenu class.
# Added 'can not find directory' Error prevent code on final version.
# 위 클래스 메서드들을 호출해서 프로그램 본래의 목적을 달성하기 위한 실행함수.
def runprogram1(ingt1, ingt2):
    m_names = ChoosingMenu.ret_m_names()
    if m_names == None:
        return [[], ['menu 디렉토리를 찾을 수 없습니다.\n\n※경고 : 레시피 입력/수정/삭제 메뉴도 \nmenu 디렉토리를 발견할 수 없어 \n프로그램이 오작동 될 수 있으니 반드시 \nmenu_gen_(date).exe파일로 \n디렉토리 및 레시피들을 생성해 주세요!']]
    else:
        nameandingr = ChoosingMenu.ret_nameandingr(m_names)
        me = ChoosingMenu(ingt1, ingt2)
        result_index = me.find_index(m_names, nameandingr)
        result_menus = me.show_textview1(nameandingr, result_index)
        if result_menus == [[], []]:
            return [[], ['적절한 레시피가 없습니다.']]
        else:
            return result_menus

# This function not using in the GUI(main program) code, only for this module.
# GUI코드에서 runprogram1()으로 산출된 결과값을 활용하여 QTextbrowser에 출력해주므로 이 코드는 단일 모듈파일로 실행할 때만 사용됨.
def runprogram2(result_menus):
    forreturn_list = ChoosingMenu().show_textview2(result_menus)
    return forreturn_list

######################################  end of program  ################################################################
######################################    run  program  ################################################################
if __name__ == "__main__":
    a = runprogram1("양배추", None) # << Random values for test this module code.
    runprogram2(a[0])

    signal = "a"
    while signal != "q":
        signal = input("끝내시려면 q를 입력하세요: ")
    print("종료")
########################################################################################################################